#include "fft.h"
#include "complex.h"
#include "trig.h"

static float new_[2048];//always change thse to match samples!!!!
static float new_im[2048];
//is FFT, needs to be improved
float fft(float* q, float* w, int n, int m, float sample_f) {
    int a,b,r,d,e,c;//variables for ordering the algorithm
    int k,place;//variables for math (kth bucket, n points)
    a=n/2;//halfway point
    b=1;
    int i,j;//loop vars
    float real=0,imagine=0;//variables to hold real and imaginary parts
    float max,frequency;//for finding max frequency inorder to find the proper frequency

    // --- DC OFFSET REMOVAL ADDED HERE ---
    {
        float mean = 0.0f;
        for (i = 0; i < 2048; ++i) {//ensure hteze stick to the nonzeropad!
            mean += q[i];
        }
        mean /= 2048.0;
        for (i = 0; i < 2048; ++i) {
            q[i] -= mean;
        }
        // w[i] assumed to be 0 initially for real input
    }
    // --- END DC OFFSET REMOVAL ---

//This is how the FFT implementation currently works:
//1. It takes in the real and imaginary parts of the signal, the number of points (n), the number of stages (m), and the sample frequency (sample_f).
//2. It performs an ordering algorithm to rearrange the input data.
//We perform the ordering algorithm to ensure that the data is in the correct order for the FFT, so that a split in the middle is the same as a split into even and odds.
//3. It then performs the FFT computation in a series of stages, using the Cooley-Turkey algorithm.
//This is essentially just running the DFT with divide and conquer
//4. Finally, it calculates the magnitudes of the frequency components to find the dominant frequency in the signal.

    // ORdering algorithm
    for(i=0; i<(m-1); i++){//for each stage
        d=0;
        for (j=0; j<b; j++){//for each section
            for (c=0; c<a; c++){    //for each point(bin) in section
                e=c+d;
                new_[e]=q[(c*2)+d];
                new_im[e]=w[(c*2)+d];
                new_[e+a]=q[2*c+1+d];
                new_im[e+a]=w[2*c+1+d];
            }// the points are now in reversed order in each section
            d+=(n/b);
        }
        for (r=0; r<n;r++){
            q[r]=new_[r];
            w[r]=new_im[r];
        }
        b*=2;
        a=n/(2*b);
    }
    //end ordering algorithm

    b=1;
    k=0;
    for (j=0; j<m; j++){//for each power of 2

    //MATH (ORIGINAL VERSION)
    /*
        for(i=0; i<n; i+=2){//for each pair
            if (i%(n/b)==0 && i!=0)//increment k every n/b points (note its the kn/N part of DFT but now its kn/b)
                k++;
            real=mult_real(q[i+1], w[i+1], cosine(-PI*k/b), sine(-PI*k/b));
            imagine=mult_im(q[i+1], w[i+1], cosine(-PI*k/b), sine(-PI*k/b));
            new_[i]=q[i]+real;
            new_im[i]=w[i]+imagine;
            new_[i+1]=q[i]-real;
            new_im[i+1]=w[i]-imagine;

        }
        for (i=0; i<n; i++){
            q[i]=new_[i];
            w[i]=new_im[i];
        }
    */
    //END MATH (ORIGINAL VERSION)

    // --- MATH (OPTIMIZED TWIDDLE USAGE) ---
        k = 0;
        // twiddle for k=0 is 1 + j0, so start with that
        float cos_k = 1.0f;
        float sin_k = 0.0f;
        float angle;

        for (i = 0; i < n; i += 2) { // for each pair
            if (i % (n / b) == 0 && i != 0) {
                // increment k every n/b points, then update twiddle once per k
                k++;
                angle = -PI * (float)k / (float)b;
                cos_k = cosine(angle);
                sin_k = sine(angle);
            }

            // complex value at i+1: xr + j xi
            float xr = q[i+1];
            float xi = w[i+1];

            // (xr + j xi) * (cos_k + j sin_k)
            real    = xr * cos_k - xi * sin_k;
            imagine = xr * sin_k + xi * cos_k;

            // butterfly
            new_[i]     = q[i] + real;
            new_im[i]   = w[i] + imagine;
            new_[i+1]   = q[i] - real;
            new_im[i+1] = w[i] - imagine;
        }

        for (i = 0; i < n; i++) {
            q[i] = new_[i];
            w[i] = new_im[i];
        }
    // --- END MATH (OPTIMIZED TWIDDLE USAGE) ---

    //REORDER
        for (i=0; i<n/2; i++){
            new_[i]=q[2*i];
            new_[i+(n/2)]=q[2*i+1];
            new_im[i]=w[2*i];
            new_im[i+(n/2)]=w[2*i+1];
        }
        for (i=0; i<n; i++){
            q[i]=new_[i];
            w[i]=new_im[i];
        }
    //END REORDER
        b*=2;
        k=0;
    }

    //find magnitudes
    max=0;
    place=1;
    for(i=1;i<(n/2);i++) {
        new_[i]=q[i]*q[i]+w[i]*w[i];
        if(max < new_[i]) {
            max=new_[i];
            place=i;
        }
    }

    float s=sample_f/n; //spacing of bins

    frequency = (sample_f/n)*place;

    //curve fitting for more accuarcy
    //assumes parabolic shape and uses three point to find the shift in the parabola
    //using the equation y=A(x-x0)^2+C
    float y1=new_[place-1],y2=new_[place],y3=new_[place+1];
    float x0=s+(2*s*(y2-y1))/(2*y2-y1-y3);
    x0=x0/s-1;

    if(x0 <0 || x0 > 2) { //error
        return 0;
    }
    if(x0 <= 1)  {
        frequency=frequency-(1-x0)*s;
    }
    else {
        frequency=frequency+(x0-1)*s;
    }

    return frequency;
    //the actual math part of thje FFT can be optimized further by removing some things
}
