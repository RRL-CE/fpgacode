#include "fft.h"
#include "complex.h"
#include "trig.h"
#include <stdlib.h>

//static float new_[1024];
//static float new_im[1024];
//is FFT, needs to be improved

#ifndef PI
#define PI 3.14159265358979323846f
#endif

// Max FFT length this implementation supports.
// Your current main uses n = 2048, m = 11.
#define FFT_MAX_N 2048
#define FFT_MAX_M 11

// How many real input samples we use for DC removal
// (you were using 256 in your float version).
#define FFT_DC_SAMPLES 256

// ---------- Fixed-point helpers (Q1.31) ----------

typedef int32_t q31_t;

// Convert float in [-1, 1) to Q1.31
static inline q31_t float_to_q31(float x)
{
    if (x >= 1.0f)  x = 0.999999f;
    if (x <= -1.0f) x = -1.0f;
    return (q31_t)(x * 2147483648.0f);  // 2^31
}

// Convert Q1.31 to float
static inline float q31_to_float(q31_t x)
{
    return (float)x / 2147483648.0f;
}

// Q1.31 multiply: (a * b) >> 31
static inline q31_t q31_mul(q31_t a, q31_t b)
{
    int64_t t = (int64_t)a * (int64_t)b;
    return (q31_t)(t >> 31);
}

// ---------- Static buffers ----------

// Fixed-point buffers for FFT (real & imag)
static q31_t iq[FFT_MAX_N];
static q31_t iw[FFT_MAX_N];

// Twiddle table for up to FFT_MAX_N
static q31_t tw_re[FFT_MAX_N / 2];
static q31_t tw_im[FFT_MAX_N / 2];
static int   twiddles_ready = 0;
static int   twiddle_n      = 0;   // n that the current twiddles are built for

// Buffer for power spectrum (float) when finding max bin
static float power_buf[FFT_MAX_N];

// ---------- Bit reversal helper ----------

static unsigned reverse_bits(unsigned x, int bits)
{
    unsigned r = 0;
    for (int i = 0; i < bits; ++i) {
        r = (r << 1) | (x & 1);
        x >>= 1;
    }
    return r;
}

// ---------- Twiddle initialization (once per n) ----------

static void fft_init_twiddles(int n)
{
    // Only recompute if n changed or never initialized
    if (twiddles_ready && twiddle_n == n)
        return;

    int half = n / 2;
    for (int k = 0; k < half; ++k) {
        float angle = -2.0f * PI * (float)k / (float)n;
        float c = cosine(angle);
        float s = sine(angle);
        tw_re[k] = float_to_q31(c);
        tw_im[k] = float_to_q31(s);
    }

    twiddle_n = n;
    twiddles_ready = 1;
}

// ---------- Main FFT (fixed-point core, same external API) ----------

// q: real input (float, length n)
// w: imag input (float, length n)
// n: FFT length (must be <= FFT_MAX_N, power of 2)
// m: log2(n)
// sample_f: sampling frequency (float)
float fft(float* q, float* w, int n, int m, float sample_f)
{
    int i;

    if (n > FFT_MAX_N || m > FFT_MAX_M) {
        // unsupported configuration
        return 0.0f;
    }

    // --- DC OFFSET REMOVAL on first FFT_DC_SAMPLES of q[] (float), like before ---
    {
        float mean = 0.0f;
        int used = FFT_DC_SAMPLES;
        if (used > n) used = n;

        for (i = 0; i < used; ++i) {
            mean += q[i];
        }
        mean /= (float)used;

        for (i = 0; i < used; ++i) {
            q[i] -= mean;
        }
        // w[i] assumed 0 initially for real input
    }
    // --- END DC OFFSET REMOVAL ---

    // --- Convert float input into fixed-point buffers iq/iw (Q1.31) ---
    for (i = 0; i < n; ++i) {
        iq[i] = float_to_q31(q[i]);
        iw[i] = float_to_q31(w[i]);  // usually 0
    }

    // Initialize twiddles for this n
    fft_init_twiddles(n);

    // --- Bit-reversal permutation in-place on iq/iw ---
    for (i = 0; i < n; ++i) {
        unsigned ri = reverse_bits((unsigned)i, m);
        if (ri > (unsigned)i && ri < (unsigned)n) {
            // swap iq[i] <-> iq[ri], iw[i] <-> iw[ri]
            q31_t tr = iq[i];
            iq[i] = iq[ri];
            iq[ri] = tr;

            q31_t ti = iw[i];
            iw[i] = iw[ri];
            iw[ri] = ti;
        }
    }

    // --- Cooley-Tukey radix-2 DIT FFT, fixed-point ---
    // Stage loop: s = 1..m (where stage size = 2^s)
    for (int s = 1; s <= m; ++s) {
        int mval   = 1 << s;      // size of this stage's butterfly group
        int half   = mval >> 1;   // butterflies per group
        int stride = n / mval;    // twiddle index step

        for (int k = 0; k < n; k += mval) {
            for (int j = 0; j < half; ++j) {
                int i0 = k + j;        // "even" index
                int i1 = k + j + half; // "odd" index

                // Twiddle index
                int idx = j * stride;
                q31_t wr = tw_re[idx];
                q31_t wi = tw_im[idx];

                // Fetch and scale down by 1 bit to reduce overflow growth
                // (block floating: divide by 2 at each stage)
                q31_t ur = iq[i0] >> 1;
                q31_t ui = iw[i0] >> 1;
                q31_t vr = iq[i1] >> 1;
                q31_t vi = iw[i1] >> 1;

                // v * W (complex multiply) in Q1.31
                q31_t tr = q31_mul(vr, wr) - q31_mul(vi, wi);
                q31_t ti = q31_mul(vr, wi) + q31_mul(vi, wr);

                // u + vW
                iq[i0] = ur + tr;
                iw[i0] = ui + ti;
                // u - vW
                iq[i1] = ur - tr;
                iw[i1] = ui - ti;
            }
        }
    }

    // --- Magnitude & peak detection (convert to float for this part) ---
    float max = 0.0f;
    int   place = 1;

    int half_n = n / 2;
    for (i = 1; i < half_n; ++i) {
        float re = q31_to_float(iq[i]);
        float im = q31_to_float(iw[i]);
        float p  = re*re + im*im;
        power_buf[i] = p;
        if (p > max) {
            max = p;
            place = i;
        }
    }

    if (place <= 0 || place >= (half_n - 1)) {
        // peak at edge or something odd
        return (sample_f / (float)n) * (float)place;
    }

    float s = sample_f / (float)n;  // bin spacing

    // --- Parabolic interpolation around the peak (place-1, place, place+1) ---
    {
        float y1 = power_buf[place - 1];
        float y2 = power_buf[place];
        float y3 = power_buf[place + 1];

        float frequency = (sample_f / (float)n) * (float)place;

        float denom = (2.0f * y2 - y1 - y3);
        if (denom == 0.0f) {
            return frequency;
        }

        float x0 = s + (2.0f * s * (y2 - y1)) / denom;
        x0 = x0 / s - 1.0f;

        if (x0 < 0.0f || x0 > 2.0f) {
            // curve fit failed; return basic bin center
            return frequency;
        }

        if (x0 <= 1.0f) {
            frequency = frequency - (1.0f - x0) * s;
        } else {
            frequency = frequency + (x0 - 1.0f) * s;
        }

        return frequency;
    }
}
