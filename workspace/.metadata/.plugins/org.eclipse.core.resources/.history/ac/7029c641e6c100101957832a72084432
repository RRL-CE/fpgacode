/*
 * Copyright (c) 2009-2012 Xilinx, Inc.  All rights reserved.
 *
 * Xilinx, Inc.
 * XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" AS A
 * COURTESY TO YOU.  BY PROVIDING THIS DESIGN, CODE, OR INFORMATION AS
 * ONE POSSIBLE   IMPLEMENTATION OF THIS FEATURE, APPLICATION OR
 * STANDARD, XILINX IS MAKING NO REPRESENTATION THAT THIS IMPLEMENTATION
 * IS FREE FROM ANY CLAIMS OF INFRINGEMENT, AND YOU ARE RESPONSIBLE
 * FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE FOR YOUR IMPLEMENTATION.
 * XILINX EXPRESSLY DISCLAIMS ANY WARRANTY WHATSOEVER WITH RESPECT TO
 * THE ADEQUACY OF THE IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO
 * ANY WARRANTIES OR REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE
 * FROM CLAIMS OF INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE.
 *
 */

/*
 * helloworld.c: simple test application
 *
 * This application configures UART 16550 to baud rate 9600.
 * PS7 UART (Zynq) is not initialized by this application, since
 * bootrom/bsp configures it to baud rate 115200
 *
 * ------------------------------------------------
 * | UART TYPE   BAUD RATE                        |
 * ------------------------------------------------
 *   uartns550   9600
 *   uartlite    Configurable only in HW design
 *   ps7_uart    115200 (configured by bootrom/bsp)
 */

#include <stdio.h>
#include "xil_cache.h"
#include <mb_interface.h>

#include "xparameters.h"
#include <xil_types.h>
#include <xil_assert.h>

#include <xio.h>
#include "xtmrctr.h"
#include "fft.h"
#include "note.h"
#include "stream_grabber.h"

#include <stdint.h>



//added by me
#include "performance_analyzer.h"

#define SAMPLES 512 // AXI4 Streaming Data FIFO has size 512//I made it 4x bigger
//this *4 gives the 2048 used to calcualte sampling frequency, this is because with decimation/4-1 averaging by 4, period increases by 4 so freq decreases by 4
#define M 9 //2^m=samples
#define CLOCK 100000000.0 //clock speed

int int_buffer[SAMPLES];
// OLD:
// static float q[SAMPLES];
// static float w[SAMPLES];

// NEW:
static int32_t q[SAMPLES];   // Q1.31 real
static int32_t w[SAMPLES];   // Q1.31 imag (usually 0)

unsigned seqf, seql, seq_old=0;

//void print(char *str);

void read_fsl_values(int32_t* q, int n) {
    int i;

    const int RAW_SAMPLES   = 2048;        // number of raw samples to grab
    const int DECIM_FACTOR  = 4;           // 4:1 averaging
    const int OUT_SAMPLES   = RAW_SAMPLES / DECIM_FACTOR;  // 512

    int max_out = OUT_SAMPLES;
    if (max_out > n) max_out = n;          // n should be 512 (SAMPLES)

    stream_grabber_start();
    stream_grabber_wait_enough_samples(RAW_SAMPLES);
    seql = stream_grabber_read_seq_counter();          // last seq
    seqf = stream_grabber_read_seq_counter_latched();  // first seq

    // Read RAW_SAMPLES into int_buffer (now large enough)
    for (i = 0; i < RAW_SAMPLES; i++) {
        int_buffer[i] = stream_grabber_read_sample(i);
    }

    // 4:1 averaging + scaling to volts, then to Q1.31
    for (i = 0; i < max_out; i++) {
        int idx = i * DECIM_FACTOR;
        int64_t sum =
            (int64_t)int_buffer[idx] +
            (int64_t)int_buffer[idx + 1] +
            (int64_t)int_buffer[idx + 2] +
            (int64_t)int_buffer[idx + 3];

        int32_t avg = (int32_t)(sum / DECIM_FACTOR); // integer average

        // Original float scaling: 3.3 * avg / 2^26
        float v = 3.3f * (float)avg / 67108864.0f;

        // Convert that voltage to Q1.31
        q[i] = float_to_q31(v);
    }

    // Zero-pad any remaining FFT slots (if n > OUT_SAMPLES)
    for (i = max_out; i < n; i++) {
        q[i] = 0;
    }
}




int main() {
   float sample_f;
   int l;
   int ticks; //used for timer
   uint32_t Control;
   float frequency;

   Xil_ICacheInvalidate();
   Xil_ICacheEnable();
   Xil_DCacheInvalidate();
   Xil_DCacheEnable();

   //set up timer
   XTmrCtr timer;
   XTmrCtr_Initialize(&timer, XPAR_TMRCTR_0_DEVICE_ID);
   Control = XTmrCtr_GetOptions(&timer, 0) | XTC_CAPTURE_MODE_OPTION | XTC_INT_MODE_OPTION;
   XTmrCtr_SetOptions(&timer, 0, Control);//control option on a Nexys A7100 board does the following:

   performance_analyzer_init();

                                          


   // print("Hello World\n\r");//not needed

   XTmrCtr_Start(&timer, 0);
   int i = 100;
   while(i>0) {
	   xil_printf("i: %d",i);

      //Read Values from Microblaze buffer, which is continuously populated by AXI4 Streaming Data FIFO.
      read_fsl_values(q, SAMPLES);//leaving at old values

      ticks=XTmrCtr_GetValue(&timer, 0);
      printf("Time %d, Seqf %d, Seql %d, Seq_off %d\n", ticks, seqf, seql, seqf-seq_old);
      seq_old = seql;
      //times how long reading took

      sample_f = 100*1000*1000/8192.0;
      //is the sampling frequency based on clock speed/2048 (default code uses decimation by 4) try to change to 4-1 average for better accuracy
      //xil_printf("sample frequency: %d \r\n",(int)sample_f);

      //zero w array
      for (l = 0; l < SAMPLES; l++)
          w[l] = 0;

      // --- FFT timing start ---
      int fft_start_ticks = XTmrCtr_GetValue(&timer, 0);

      frequency = fft(q, w, SAMPLES, M, sample_f);

      int fft_end_ticks = XTmrCtr_GetValue(&timer, 0);
      int fft_ticks = fft_end_ticks - fft_start_ticks;
      // --- FFT timing end ---

      xil_printf("frequency: %d Hz, FFT_ticks: %d\r\n",
                 (int)(frequency + 0.5f), fft_ticks);
//      i--;
   }

   Prof_PrintAll();

   return 0;
}
